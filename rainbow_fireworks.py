# Code generated by MCHP Chatbot
import tkinter as tk
import random
import math

class FireworksApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Rainbow Fireworks Buttons")
        self.root.geometry("900x600")

        # Top frame for rainbow buttons
        btn_frame = tk.Frame(root)
        btn_frame.pack(side=tk.TOP, fill=tk.X, padx=10, pady=10)

        # Canvas for fireworks
        self.canvas = tk.Canvas(root, bg="black", highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True)

        # Rainbow palette (approx)
        self.rainbow = [
            ("Red",    "#FF0000"),
            ("Orange", "#FF7F00"),
            ("Yellow", "#FFFF00"),
            ("Green",  "#00FF00"),
            ("Blue",   "#0000FF"),
            ("Indigo", "#4B0082"),
            ("Violet", "#8F00FF"),
        ]

        for name, color in self.rainbow:
            b = tk.Button(
                btn_frame,
                text=name,
                bg=color,
                fg="white" if name in ("Red", "Blue", "Indigo", "Violet") else "black",
                activebackground=color,
                relief=tk.RAISED,
                command=lambda c=color: self.launch_firework(c)
            )
            b.pack(side=tk.LEFT, padx=5, ipadx=10, ipady=6)

        # Resize handling (optional; canvas already expands)
        self.root.bind("<Configure>", lambda e: None)

    def launch_firework(self, color):
        """Create a firework burst with particles in the given color."""
        w = self.canvas.winfo_width()
        h = self.canvas.winfo_height()

        # Choose a burst location (upper ~70% of canvas)
        cx = random.randint(100, max(101, w - 100))
        cy = random.randint(80,  max(81, int(h * 0.7)))

        # Make multiple particles
        particle_count = random.randint(40, 80)
        particles = []

        for _ in range(particle_count):
            angle = random.random() * 2 * math.pi
            speed = random.uniform(3.0, 9.0)

            vx = math.cos(angle) * speed
            vy = math.sin(angle) * speed

            size = random.uniform(2.0, 4.5)

            # Create a small oval for a particle
            pid = self.canvas.create_oval(
                cx - size, cy - size, cx + size, cy + size,
                fill=color, outline=""
            )

            # Each particle has position, velocity, life, and size
            particles.append({
                "id": pid,
                "x": cx,
                "y": cy,
                "vx": vx,
                "vy": vy,
                "life": random.randint(18, 30),
                "size": size
            })

        # Animate
        self.animate_particles(particles, color)

    def animate_particles(self, particles, color):
        gravity = 0.25
        drag = 0.985

        alive = False
        for p in particles:
            if p["life"] <= 0:
                continue

            alive = True
            p["life"] -= 1

            # Update velocity (gravity + drag)
            p["vx"] *= drag
            p["vy"] = p["vy"] * drag + gravity

            # Update position
            p["x"] += p["vx"]
            p["y"] += p["vy"]

            # Shrink slightly over time
            p["size"] *= 0.985
            s = max(0.5, p["size"])

            # Move oval to new position
            self.canvas.coords(
                p["id"],
                p["x"] - s, p["y"] - s,
                p["x"] + s, p["y"] + s
            )

            # Fade-out effect by stippling near the end (simple visual trick)
            if p["life"] < 8:
                self.canvas.itemconfigure(p["id"], stipple="gray50")

            if p["life"] <= 0:
                self.canvas.delete(p["id"])

        if alive:
            # Schedule next frame
            self.root.after(16, lambda: self.animate_particles(particles, color))

def main():
    root = tk.Tk()
    app = FireworksApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()
